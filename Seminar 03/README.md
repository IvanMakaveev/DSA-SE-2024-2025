# Семинар №3 - Алгоритми за сортиране
**Сортирането е изчислителна задача**, в която се търси пермутация на елементите на входна колекция, така че резултатната пермутация да има свойството, че за всеки два индекса i и j, за които i < j , елементът на индекс i е <= от този на позиция j

## "Бавни" сортиращи алгоритми
### Bubble Sort (Optimized)
От така наречените "бавни" сортировки, Bubble sort намира може би най-малко приложение в практиката. Нека разгледаме някои от неговите показатели:

Сложност по време в най-добрият случай: **Theta(n)**

Сложност по време в среден случай: **Theta(n^2)**

Сложност по време в най-лошият случай: **Theta(n^2)**

Сложност по памет: **Theta(1)**

Стабилност: **Да**

Адаптивност: Зависи (в общия случай - **Не**)

### Selection Sort (Optimized)
Макар с висока сложност дори и в най-добрият случай, оптимизираната версия на Selection sort притежава една много важна характеристика - **прави минимален брой swap-ове**. Тази негова характеристика намира широко приложение за данни, при които операцията swap е тежка. 

Сложност по време в най-добрият случай: **Theta(n^2)**

Сложност по време в среден случай: **Theta(n^2)**

Сложност по време в най-лошият случай: **Theta(n^2)**

Сложност по памет: **Theta(1)**

Стабилност: **Не**

Адаптивност: **Не**

### Insertion Sort
Въпреки че е с квадратична сложност, Insertion sort е много разпространен алгоритъм за сортиране поради свойството си "адаптивност". Сортиращ алгоритъм наричаме **адаптивен**, когато работи бързо за почти-сортирани данни. Точно поради това свое предимство, Insertion sort е част от default-ната имплементация на std::sort().

Сложност по време в най-добрият случай: **Theta(n)**

Сложност по време в среден случай: **Theta(n^2)**

Сложност по време в най-лошият случай: **Theta(n^2)**

Сложност по памет: **Theta(1)**

Стабилност: **Да**

Адаптивност: **Да**

## "Бързи" сортиращи алгоритми
Представените по-долу алгоритми Merge Sort и Quick Sort са построени по схемата **Разделяй-и-Владей**. Тази схема за съставяне на алгоритми се състои от три стъпки:

1) Разбиване на проблема на подзадачи
2) Решаване на подзадачите
3) Акумулиране на резултат

Обикновено целим по такъв начин да разбием задачата на подпроблеми, че в стъпка 2 да можем рекурсивно да приложим решението на "големият" проблем.

### Merge Sort
Бърз и много широко използван алгоритъм за сортиране. Често е първият избор при работа със свързани структури от типа на Linked List.

Сложност по време: **Theta(n*log(n))**

Сложност по памет: **Theta(n)**

Стабилност: **Да**

Адаптивност: **Не**

### Quick Sort
Макар и с висока сложност в най-лошият случай, бързата сортировка Quick Sort се използва често поради ниската вероятност за влизане в worst case. Част е от имплементацията на STL функцията std::sort(). 

Сложност по време в най-добрият случай: **Theta(n*log(n))**

Сложност по време в среден случай: **Theta(n*log(n))**

Сложност по време в най-лошият случай: **Theta(n^2)**

Сложност по памет (абстрактна): **Theta(1)**

Сложност по памет (реална) в най-добрият случай: **Theta(log(n))**

Сложност по памет (реална) в най-лошият случай: **Theta(n)**

Стабилност: **Не**

Адаптивност: **Анти-адаптивен** - колкото по-случаен и неподреден е входът, толкова по-добре ще работи 

## Сортиращи алгоритми неработещи чрез преки сравнения

### Counting Sort (Stable)
В най-простата си имплементация преброяваме броя срещания на всеки елементи просто толкова пъти го долепяме в резултатата колекция. За непримитивни типове обаче това би довело до проблеми, един от които е загубата на стабилност. Оптимизираната версия решава тези проблеми без да променя асимптотиката по време на решението. Разбира се, за сметка на стабилност има загуба на бързодействие под формата на по-висока мултипликативна константа.

С **k** ще бележим най-голямата стойност в колекцията, която сортираме (като предполагаме, че работим само с естествени числа).

Сложност по време: **Theta(n + k)**

Сложност по памет: **Theta(n + k)**

Стабилност: **Да**

Адаптивност: **Не**

## Решаване на задачи за сортиране

[01. Squares of Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/description/)

[02. Sort Students by Kth Score](https://leetcode.com/problems/sort-the-students-by-their-kth-score/)

[03. Max Product of Three](https://leetcode.com/problems/maximum-product-of-three-numbers/description/)

[04. Intersection of Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/)

[05. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/description/)

[06. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/description/)

[07. Find the Difference](https://leetcode.com/problems/find-the-difference/description/)

[08. Evens and Odds](./Solutions/Evens%20and%20Odds/Task.md)

[09. Negatives Before Positives](./Solutions/Evens%20and%20Odds/Task.md)

[10. Order in Chaos](https://www.hackerrank.com/contests/sda-test1-2022-2023/challenges/challenge-3676)

[11. Kth Largest Element](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)

[12. Earliest Possible Day of Bloom](https://leetcode.com/problems/earliest-possible-day-of-full-bloom/description/)









