# Семинар №8 - Динамично Програмиране

## Мотивация за избора на техниката ДП
Когато разглеждахме алгоритмите за сортиране **Merge Sort** и **Quick Sort** се запознахме със схемата **Разделяй-И-Владей**, която цели да разбие дадена голяма задача на по-малки подзадачи, които могат да се решат аналогично на основният проблем. Този подход работи добре, когато разбиването на подзадачи няма сечение. Какво се случва обаче, когато подзадачите имат някаква зависимост между тях (или с други думи - **когато се застъпват**)?

Ако си припомним наивиният алгоритъм за генериране на числата на Фибоначи, там имахме следното извикване:

```c++
return fib(n-1) + fib(n-2);
```

Нека разгледаме дървото на изпълнение, ако така съставим и нашият код

![binaryTree.png](./Images/fibonacci-naive.png)

Можем да забележим, че със син цвят са отбелязани първите достигания до всяко едно от числата, а с червен - всяко повторно пресмятане на вече намерен член на редицата.

Тук ясно се вижда едно от ограниченията на схемата Разделяй-И-Владей. Ако проблемът не може да се раздели на независими/незастъпващи се подпроблеми, то тя става неефикасна.

Схемата **Динамично Програмиране** от своя страна е пригодена именно за справяне със **задачи, които се разбиват до застъпващи се подзадачи.** Както ще видим по-нататък, тя е инструмент, който може да се използва за ефикасното решаване на множество задачи, включително и бързото пресмятане на редицата на Фибоначи.

## Общ преглед на подхода ДП
В книгата Introduction to Algorithms, Динамичното Програмиране е определено, като аналог на схемата Разделяй-И-Владей от гледна точка на това, че и двата подхода разрешават даден проблем, като комбинират резултата от разбиването му на подпроблеми. Разликата обаче идва от там, че ДП се прилага, когато **подзадачите се застъпват**.

Но какво означава подзадачите да се застъпват? Това означава, че когато разбием подзадачите на под-подзадачи, някои от тези под-подзадачи съвпадат.

Как обаче прилагаме Динамично Програмиране?

Първо, ще разгледаме понятието конституент:

* **Непосредствен конституент** на дадена задача наричаме всички подзадачи, чрез които, ако знаем техните решения, можем ефикасно да построим решение на основната задача.

  * Пример: Непосредствени конституенти на задачата Fib(x) са Fib(x-1) и Fib(x-2)

  * Забележка: в случая това не е формална дефиниция на конституент, тъй като в рамките на курса не разглеждаме понятия като "екземпляр на изчислителна задача", което би било по-точно да се използва.

* **Конституенти** на дадена задача наричаме множеството от всички непосредствени конституенти на задачата обединено с множествата от конституенти на непосредствените конституенти.
  
  * Или иначе казано - множеството от всички подпроблеми, които трябва да решим, за да достигнем до крайният резултат.
  
  * Пример: За задачата Fibb(n) конституентите са в множеството {Fibb(1), Fibb(2), Fibb(3),... Fibb(n-1)}

Ако даден конституент няма от своя страна непосредствени конституенти, то той ще бъде **База** в процеса на изчисляване.

Ако знаем кои са **Конституентите** на нашия проблем, можем да конструираме търсеното решение сравнително по-бързо от схемата **Разделяй-И-Владей** при застъпващи се подзадачи. Това е така, тъй като докато в схемата Разделяй-И-Владей ще имаме повторно изчисление на голям брой от конституентите, тук, щом знаем кои са, можем да ги пресметнем еднократно и да намалим драстично асимптотичната сложност.

Още едно важно наблюдение за схемата **Динамично Програмиране** е, че не винаги ни интересуват самите конституенти, а може би някаква част от информацията, която те биха ни донесли. Също така, понякога те могат също да са необятно много на брой, поради което се въвежда и понятието **Състояния**.

**Състоянията** са краен набор от информация, извлечен от **конституентите**, който ни позволява да решим нашата основна задача.

(Бележка: Разбира се, понякога състоянията могат да съвпадат с конституентите, както при Фибоначи например)

Следващият естествено възникващ въпрос е - **Как дефинираме състояния?**

Тук вече идва моментът на "досещане". Чрез анализиране на задачата и достатъчно опит, човек може да извлече необходимият минимум от информация, който може да ни доведе до търсеният отговор. 

Най-често ДП влиза в сила, когато търсим оптимално решение (т-нар Изчислителни Задачи за оптимизиране) - чести примери са:

* Задачи за броене на комбинаторни структури
* Задачи за оптимални скобувания на редици
* Задачи за оптимални подмножества
* Задачи за scheduling
* Задачи за подредици и поднизове
* И много други...

## Подходи Bottom-Up и Top-Down
Двата най-често срещани подхода за прилагане на схемата Динамично Програмиране се наричат **Bottom-up** и **Top-down**

Подходът **Top-down** започва, като директно разглежда поставената задача. Задачата се разбива на подзадачи и ако знаем отговорът им (вече сме срещнали това състояние) можем директно да пресметнем задачата. В противен случай прилагаме **рекурсивно** подходът върху подзадачите. Щом решим дадена подзадача, резултатът й се запазва в кеш (техника, позната още като **Мемоизация**), за да можем бързо след това да преизползваме резултата, ако се наложи.

Подходът **Bottom-up** изисква предварителен анализ на задачата и пресмятане на **базистните състояния** (породени от базистните конституенти). Последователно се изчисляват решенията, използвайки откритото рекурентно взаимоотоношение. Състоянията се записват в таблица (техника, наречена **Табулация**). Този процес често е **итеративен**.

Подходът **Bottom-up** съвместно с **Табулация** често е по-оптимален от **Top-Down Мемоизацията**, но е по-труден за откирване и съставяне.

## Решаване на задачи
[01. Fibonacci](https://leetcode.com/problems/fibonacci-number/description/)

[02. Binomial Coefficient]()

[03. Matrix - Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/description/)

[04. House Robber](https://leetcode.com/problems/house-robber/description/)

[05. House Painter]()

[06. Subset Sum Problem]()

[07. Knapsack problem]()

[08. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/description/) - забележете разликата между тази задача и задачата Welcome To The Jungle към темата за Stack. Защо тук няма да работи с монотонен стек?

[09. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/)

[10. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/description/)

[11. Matrix Chain Multiplication]()