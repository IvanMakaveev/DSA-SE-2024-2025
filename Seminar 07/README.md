# Семинар №7 - Дървета, Двоични наредени дървета (BST), Самобаланисращи се дървета (AVL, Red-Black)

## Дърво - дефиниция и имплементация
В дискретната математика, за понятието **Дърво** най-често се дават следните две дефиниции:

1) Частен случай на граф - D(V,E) е дърво, ако е свързан, ацикличен граф.
2) Кореново дърво - индуктивна дефиниция:
    * **База:** Дървото D({r}, {}) с единствен лист r и корен r
    * **Стъпка:** Нека D(V, E) е кореново дърво със списък на листата L = {l_1, l_2, l_3..., l_k} и корен r
      * Нека u е елемент, непринадлежащ на V, а пък v е връх от V. Тогава можем да дефинираме ново кореново дърво D'=(V', E') с корен r, където V' = Union(V, {u}), a E'= Union(E, {{v, u}}), като то ще има списък на листата L':
        * Ако v е било листото l_i от L => L' = {l_1, l_2, ..., l_i-1, u, l_i+1, ..., l_k}
        * Ако v не е било листото L => L' = Union(L, {u})

С други думи, получаваме **индуктивно (постъпково) построена, свързана, йерархична структура**. Силата на това представяне на данните идва от изборът ни по какви правила да модифицираме дървото, което среща своето отражение в сложностите на различните операции.

(**Наблюдение:** от дефиницията се вижда, че за всеки добавен възел се добавя и точно 1 ребро. В базовият случай имаме 1 възел и 0 ребра, откъдето следва, че |V| = |E| + 1)

### Имплементация и представяния в паметта
Нека разгледаме как можем да представим подобна структура от данни на практика:

#### **Първи начин:** Чрез структура за възлите
```c++
template <class T>
struct Node
{
    T data;
    Node* parent;
    std::vector<Node*> children;
}
```

Това е най-общият и доста често срещан начин за представяне на възлите на дърво. Всяко дърво има информация за своят родител, както и за своите наследници. Не е задължително да имате указател към родителския възел. Достатъчно е да знаете кой е кореновият елемент на дървото.

#### **Втори начин:** Чрез списък на родителите

Този подход е полезен, когато върховете ни са номерирани със стойности в интервал [0, N]. Създаваме масив с N елемента, в който на всеки индекс i се намира номерът на родителя на възел с номер i. Кореновият елемент най-често се обозначава като родител сам на себе си (ако root елементът се номер 4, то parentArr[4] = 4).

#### **Трети начин:** Чрез списък за пълно двоично дърво

Двоично дърво (**Binary tree**) наричаме дърво, за което всеки възел има най-много две деца (ляво и дясно).

Пълно дърво (**Complete tree**) наричаме дърво, за което всяко ниво е запълнено изцяло, с изключение на последното, което е запълнено донякъде, но задължително отляво-надясно. 

Можем да използваме следното представяне за пълно двоично дърво, чиито върхове са номерирани от 0 до N в реда на обхождане в широчина:
* Създаваме вектор, за който на индекс 0 стои коренът на дървото.
* За всеки елемент с номер i, неговите деца са записани на позиции 2i+1 (ляво дете) и 2i+2 (дясно дете). 

(Пример за това представяне ще видим на темата за двоични пирамиди)

#### **Други начини:** Чрез представяния на граф
Спрямо първата дефиниця, която разгледахме, дървото е частен случай на граф. Следователно всяко от представянията за графи може да се използва, за да се зададе и структурата на дърво. Примери за това са:
* Списък на ребрата
* Списък на наследниците
* Матрица на съседство

### Двоично наредено дърво (за търсене) - BST
Двоично наредено дърво е дърво, за което стойността на всеки възел е по-голяма от всички елементи в лявото му поддърво и е по-малка от всички елементи в дясното му поддърво.

Забележете, че не е достатъчно да сръвним възелът с неговите преки ляв и десен наследник, тъй като това не ни гарантира, че надолу в поддървото няма елемент, чупещ горното правило.

Името на BST идва от хубавото му свойство, че проверката дали елемент се съдържа в него е изключително проста. Сравняваме даденият елемент с кореновият елемент. Ако е по-малък, повтаряме за лавото поддърво. Ако е по-голям - за дясното. Правим го докато не открием търсеният елемент или не установим липсата му.

В дефиницията по-горе използвахме операциите "по-голямо" и "по-малко", но в реална имплементация не е задължително да сравняваме числови стойности. Най-често се използва двуместен предикат, който, ако е в сила - елементът трябва да бъде поставен в ляво от текущия, а ако не е - в дясно от текущия.

### Операции с BST - имплементации и анализ

// TODO: Имплементации

* contains:
  * Average-Case - Theta(log(n))
  * Worst-Case - Theta(n)

* insert:
  * Average-Case - Theta(log(n))
  * Worst-Case - Theta(n)

* erase:
  * Average-Case - Theta(log(n))
  * Worst-Case - Theta(n)

Важно е да забележим, че в най-лошия случай тези операции са линейни. Това се дължи на факта, че в случая говорим за обикновено BST. Едносвързан сортиран свързан списък също влиза в дефиницията на BST (така нареченото изродено BST), а търсенето в свързан списък, както знаем от предните теми, е линейно.

### Балансирано BST
**Balance Factor** - число, което оценява колко "балансиран" е всеки от върховете (дава оценка по зададен критерий). Чрез него можем да дефинираме изисквания за балансиране на дървото.

Дефинирайки **balance factor** за всеки един връх, можем да дадем оценка колко близко до желано състояние (наречено балансирано състояние) е дадено дърво. В балансирано дърво операциите са с логаритмична сложност в най-лошият случай.

Свойството "балансираност" не е задължително да бъде дефинирано чрез balance factor, но много често е удобно да се използва.

### Самобалансиращи се BST - AVL
Както името подсказва, самобалансиращите се дървета сами гарантират своята балансираност. Конкретен пример за това е AVL дървото (кръстено на своите създатели), което използва следният balance factor за оценка:

BalanceFactor(n) = Height(n->right) - Height(n->left)

(note: разглеждаме височина като брой ребра в най-дългия път от корен до кое да е листо)

Правило за балансираност: за всеки връх n, |BalanceFactor(n)| <= 1

Процесът по балансиране се случва автоматично при добавяне и премахване на елемент. В случаят на AVL дървета това се извършва чрез операциите за лява и дясна **ротация**.

// TODO - Имплементация

### Самобалансиращи се BST - Red-Black
Балансираността тук не е дефинирана чрез balance factor, а чрез редица свойства, които винаги трябва да са в сила (така наречения **инвариант**).

Инвариантът на Red-Black Tree гласи:
1) Всеки възел има цвят - черен или червен

2) Всеки NIL възел (празен възел) е черен

3) Червен възел не може да има червен наследник

4) Всеки път от произволен връх до всички NIL елементи в поддървото му трябва да преминава през равен брой черни върхове

5) Коренът винаги е черен (не е задължително, но често се прилага)

* Следствие: Ако произволен връх има точно 1 наследник, то той е червен

Балансирането отново се извършва по време на самите операции за добавяне и премахване. Отново се разчита на принципа на ротациите, но също така има случаи в които вместо ротация се предпочита обикновенно преоцветяване на върховете.

### Дървета в STL
В STL разполагаме със следните колекции, които работят именно чрез Red-Black дървета:

* `std::set<T>` - множество от елементи без повторение
* `std::multiset<T>` - множество от елементи с повторение
* `std::map<K,V>` - множество от двойки ключ-стойност
* `std::multi-map<K,V>` - множество от двойки ключ-стойност

## Решаване на задачи
[01. Max Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree)

[02. Min Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree)

[03. Validate BST](https://leetcode.com/problems/validate-binary-search-tree/)

[04. Symmetric Tree](https://leetcode.com/problems/symmetric-tree)

[05. Родословно дърво](https://www.hackerrank.com/contests/sda-hw-6-2022/challenges/parent)

[06. Царство](https://www.hackerrank.com/contests/kontrolno-3/challenges/challenge-4346)

[07. Час по рисуване](https://www.hackerrank.com/contests/sda-hw-6-2023/challenges/task3score/problem)

[08. Longest Substring Without Repeating Elements](https://leetcode.com/problems/longest-substring-without-repeating-characters)

[09. Волейболни другарчета](https://www.hackerrank.com/contests/sda-hw-8/challenges/volleyball-friends)

* Аналогично (за вкъщи) - [10. Маската на зоро](https://www.hackerrank.com/contests/sda-hw-7-2022/challenges/zoros-mask)
  
// TODO - Add map tasks